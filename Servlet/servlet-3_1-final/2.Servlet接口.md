The Servlet interface is the central abstraction of the Java Servlet API. All servlets implement this interface either directly, or more commonly, by extending a class that implements the interface. The two classes in the Java Servlet API that implement the Servlet interface are GenericServlet and HttpServlet. For most purposes, Developers will extend HttpServlet to implement their servlets.

> Servlet 接口是 Java Servlet API 的中心抽象。所有 servlet 都直接实现此接口，或者更常见的是通过扩展实现该接口的类来实现。 Java Servlet API 中实现 Servlet 接口的两个类是 GenericServlet 和 HttpServlet。对于大多数目的，开发人员将扩展 HttpServlet 来实现他们的 servlet。

## 2.1 Request Handling Methods 

> 2.1 请求处理方法

The basic Servlet interface defines a service method for handling client requests. This method is called for each request that the servlet container routes to an instance of a servlet.

> 基本的Servlet接口定义了处理客户端请求的服务方法。对于 servlet 容器路由到 servlet 实例的每个请求，都会调用此方法。

The handling of concurrent requests to a Web application generally requires that the Web Developer design servlets that can deal with multiple threads executing within the service method at a particular time.

> 处理对 Web 应用程序的并发请求通常要求 Web 开发人员设计能够处理特定时间在服务方法内执行的多个线程的 Servlet。

Generally the Web container handles concurrent requests to the same servlet by concurrent execution of the service method on different threads.

> 通常，Web 容器通过在不同线程上并发执行服务方法来处理对同一 servlet 的并发请求。

### 2.1.1 HTTP Specific Request Handling Methods 

>2.1.1 HTTP特定请求处理方法

The HttpServlet abstract subclass adds additional methods beyond the basic Servlet interface that are automatically called by the service method in the HttpServlet class to aid in processing HTTP-based requests. These methods are:

> HttpServlet 抽象子类在基本 Servlet 接口之外添加了其他方法，这些方法由 HttpServlet 类中的服务方法自动调用，以帮助处理基于 HTTP 的请求。这些方法是：

- doGet for handling HTTP GET requests

  > doGet 用于处理 HTTP GET 请求

- doPost for handling HTTP POST requests

  > doPost 用于处理 HTTP POST 请求

- doPut for handling HTTP PUT requests

  > doPut 用于处理 HTTP PUT 请求

- doDelete for handling HTTP DELETE requests

  > doDelete 用于处理 HTTP DELETE 请求

- doHead for handling HTTP HEAD requests

  > doHead 用于处理 HTTP HEAD 请求

- doOptions for handling HTTP OPTIONS requests

  > doOptions 用于处理 HTTP OPTIONS 请求

- doTrace for handling HTTP TRACE requests

  > doTrace 用于处理 HTTP TRACE 请求

Typically when developing HTTP-based servlets, a Servlet Developer will only concern himself with the doGet and doPost methods. The other methods are considered to be methods for use by programmers very familiar with HTTP programming.

> 通常，在开发基于 HTTP 的 servlet 时，Servlet 开发人员只关心 doGet 和 doPost 方法。其他方法被认为是非常熟悉HTTP编程的程序员使用的方法。

### 2.1.2 Additional Methods 

>2.1.2 附加方法

The doPut and doDelete methods allow Servlet Developers to support HTTP/1.1 clients that employ these features. The doHead method in HttpServlet is a specialized form of the doGet method that returns only the headers produced by the doGet method. The doOptions method responds with which HTTP methods are supported by the servlet. The doTrace method generates a response containing all instances of the headers sent in the TRACE request.

> doPut 和 doDelete 方法允许 Servlet 开发人员支持使用这些功能的 HTTP/1.1 客户端。 HttpServlet 中的 doHead 方法是 doGet 方法的一种特殊形式，它仅返回 doGet 方法生成的标头。 doOptions 方法响应 servlet 支持的 HTTP 方法。 doTrace 方法生成一个响应，其中包含 TRACE 请求中发送的标头的所有实例。

### 2.1.3 Conditional GET Support 

>2.1.3 有条件的 GET 支持

The HttpServlet interface defines the getLastModified method to support conditional GET operations. A conditional GET operation requests a resource be sent only if it has been modified since a specified time. In appropriate situations, implementation of this method may aid efficient utilization of network resources.

> HttpServlet 接口定义了 getLastModified 方法来支持条件 GET 操作。条件 GET 操作仅当资源自指定时间以来已被修改时才请求发送该资源。在适当的情况下，该方法的实施可以有助于网络资源的有效利用。

## 2.2 Number of Instances 

>2.2 实例数量

The servlet declaration which is either via the annotation as described in Chapter 8, “Annotations and pluggability” or part of the deployment descriptor of the Web application containing the servlet, as described in Chapter 14, “Deployment Descriptor”, controls how the servlet container provides instances of the servlet.

> servlet 声明可以通过第 8 章“注释和可插拔性”中所述的注释实现，也可以是包含 servlet 的 Web 应用程序的部署描述符的一部分（如第 14 章“部署描述符”中所述）控制 servlet 容器的方式提供 servlet 的实例。

For a servlet not hosted in a distributed environment (the default), the servlet container must use only one instance per servlet declaration. However, for a servlet implementing the SingleThreadModel interface, the servlet container may instantiate multiple instances to handle a heavy request load and serialize requests to a particular instance.

> 对于未托管在分布式环境（默认）中的 servlet，servlet 容器必须为每个 servlet 声明仅使用一个实例。然而，对于实现 SingleThreadModel 接口的 servlet，servlet 容器可以实例化多个实例来处理繁重的请求负载并将请求序列化到特定实例。

In the case where a servlet was deployed as part of an application marked in the deployment descriptor as distributable, a container may have only one instance per servlet declaration per Java Virtual Machine (JVMTM)1. However, if the servlet in a distributable application implements the SingleThreadModel interface, the container may instantiate multiple instances of that servlet in each JVM of the container.

> 如果 servlet 被部署为部署描述符中标记为可分发的应用程序的一部分，则容器的每个 Java 虚拟机 (JVMTM) 的每个 servlet 声明可能只有一个实例。但是，如果可分发应用程序中的 servlet 实现 SingleThreadModel 接口，则容器可以在容器的每个 JVM 中实例化该 servlet 的多个实例。

### 2.2.1 Note About The Single Thread Model 

>2.2.1 关于单线程模型的注意事项

The use of the SingleThreadModel interface guarantees that only one thread at a time will execute in a given servlet instance’s service method. It is important to note that this guarantee only applies to each servlet instance, since the container may choose to pool such objects. Objects that are accessible to more than one servlet instance at a time, such as instances of HttpSession, may be available at any particular time to multiple servlets, including those that implement SingleThreadModel.

> SingleThreadModel 接口的使用保证在给定 servlet 实例的服务方法中一次只有一个线程执行。需要注意的是，这种保证仅适用于每个 servlet 实例，因为容器可能会选择池化此类对象。一次可供多个 servlet 实例访问的对象（例如 HttpSession 的实例）可能在任何特定时间可供多个 servlet 访问，包括那些实现 SingleThreadModel 的 servlet。

It is recommended that a developer take other means to resolve those issues instead of implementing this interface, such as avoiding the usage of an instance variable or synchronizing the block of the code accessing those resources. The SingleThreadModel Interface is deprecated in this version of the specification.

> 建议开发人员采用其他方法来解决这些问题，而不是实现此接口，例如避免使用实例变量或同步访问这些资源的代码块。此版本的规范中已弃用 SingleThreadModel 接口。

## 2.3 Servlet Life Cycle 

>2.3 Servlet 生命周期

A servlet is managed through a well defined life cycle that defines how it is loaded and instantiated, is initialized, handles requests from clients, and is taken out of service. This life cycle is expressed in the API by the init, service, and destroy methods of the javax.servlet.Servlet interface that all servlets must implement directly or indirectly through the GenericServlet or HttpServlet abstract classes.

> servlet 通过明确定义的生命周期进行管理，该生命周期定义了 servlet 如何加载和实例化、初始化、处理来自客户端的请求以及停止服务。此生命周期在 API 中通过 javax.servlet.Servlet 接口的 init、service 和 destroy 方法表示，所有 servlet 都必须通过 GenericServlet 或 HttpServlet 抽象类直接或间接实现该接口。

### 2.3.1 Loading and Instantiation 

> 2.3.1 加载和实例化

The servlet container is responsible for loading and instantiating servlets. The loading and instantiation can occur when the container is started, or delayed until the container determines the servlet is needed to service a request.

> servlet 容器负责加载和实例化servlet。加载和实例化可以在容器启动时发生，也可以延迟到容器确定需要 servlet 来服务请求为止。

When the servlet engine is started, needed servlet classes must be located by the servlet container. The servlet container loads the servlet class using normal Java class loading facilities. The loading may be from a local file system, a remote file system, or other network services.

> 当servlet引擎启动时，servlet容器必须找到所需的servlet类。 servlet 容器使用普通的 Java 类加载工具来加载 servlet 类。加载可以来自本地文件系统、远程文件系统或其他网络服务。

After loading the Servlet class, the container instantiates it for use.

> 加载Servlet类后，容器将其实例化以供使用。

### 2.3.2 Initialization 

>2.3.2 初始化

After the servlet object is instantiated, the container must initialize the servlet before it can handle requests from clients. Initialization is provided so that a servlet can read persistent configuration data, initialize costly resources (such as JDBCTM API- based connections), and perform other one-time activities. The container initializes the servlet instance by calling the init method of the Servlet interface with a unique (per servlet declaration) object implementing the ServletConfig interface. This configuration object allows the servlet to access name-value initialization parameters from the Web application’s configuration information. The configuration object also gives the servlet access to an object (implementing the ServletContext interface) that describes the servlet’s runtime environment. See Chapter 4, “Servlet Context” for more information about the ServletContext interface.

> Servlet 对象实例化后，容器必须先初始化 Servlet，然后才能处理来自客户端的请求。提供初始化是为了让 servlet 可以读取持久配置数据、初始化昂贵的资源（例如基于 JDBCTM API 的连接）以及执行其他一次性活动。容器通过使用实现 ServletConfig 接口的唯一（每个 servlet 声明）对象调用 Servlet 接口的 init 方法来初始化 servlet 实例。该配置对象允许 Servlet 从 Web 应用程序的配置信息中访问名称-值初始化参数。配置对象还允许 servlet 访问描述 servlet 运行时环境的对象（实现 ServletContext 接口）。有关 ServletContext 接口的更多信息，请参阅第 4 章“Servlet 上下文”。

#### 2.3.2.1 Error Conditions on Initialization 

>2.3.2.1 初始化时的错误情况

During initialization, the servlet instance can throw an UnavailableException or a ServletException. In this case, the servlet must not be placed into active service and must be released by the servlet container. The destroy method is not called as it is considered unsuccessful initialization.

> 在初始化期间，Servlet 实例可能会抛出 UnavailableException 或 ServletException。在这种情况下，servlet 不得放入活动服务中，而必须由 servlet 容器释放。 destroy 方法不会被调用，因为它被认为初始化不成功。

A new instance may be instantiated and initialized by the container after a failed initialization. The exception to this rule is when an UnavailableException indicates a minimum time of unavailability, and the container must wait for the period to pass before creating and initializing a new servlet instance.

> 初始化失败后，容器可以实例化并初始化新实例。此规则的例外情况是，当 UnavailableException 指示不可用的最短时间时，容器必须等待该时间段过去，然后才能创建和初始化新的 servlet 实例。

#### 2.3.2.2 Tool Considerations 

>2.3.2.2 工具注意事项

The triggering of static initialization methods when a tool loads and introspects a Web application is to be distinguished from the calling of the init method. Developers should not assume a servlet is in an active container runtime until the init method of the Servlet interface is called. For example, a servlet should not try to establish connections to databases or Enterprise JavaBeansTM containers when only static (class) initialization methods have been invoked.

> 当工具加载和内省 Web 应用程序时静态初始化方法的触发与 init 方法的调用不同。在调用 Servlet 接口的 init 方法之前，开发人员不应假设 servlet 处于活动容器运行时中。例如，当仅调用静态（类）初始化方法时，Servlet 不应尝试建立与数据库或 Enterprise JavaBeansTM 容器的连接。

### 2.3.3 Request Handling 

>2.3.3 请求处理

After a servlet is properly initialized, the servlet container may use it to handle client requests. Requests are represented by request objects of type ServletRequest. The servlet fills out response to requests by calling methods of a provided object of type ServletResponse. These objects are passed as parameters to the service method of the Servlet interface.

> Servlet 正确初始化后，Servlet 容器可以使用它来处理客户端请求。请求由 ServletRequest 类型的请求对象表示。 servlet 通过调用所提供的 ServletResponse 类型对象的方法来填写对请求的响应。这些对象作为参数传递给 Servlet 接口的服务方法。

In the case of an HTTP request, the objects provided by the container are of types HttpServletRequest and HttpServletResponse.

> 对于 HTTP 请求，容器提供的对象类型为 HttpServletRequest 和 HttpServletResponse。

Note that a servlet instance placed into service by a servlet container may handle no requests during its lifetime.

> 请注意，由 Servlet 容器投入使用的 Servlet 实例在其生命周期内可能不会处理任何请求。

#### 2.3.3.1 Multithreading Issues 

>2.3.3.1 多线程问题

A servlet container may send concurrent requests through the service method of the servlet. To handle the requests, the Servlet Developer must make adequate provisions for concurrent processing with multiple threads in the service method.

> servlet 容器可以通过servlet 的service 方法发送并发请求。为了处理请求，Servlet 开发人员必须为服务方法中的多个线程的并发处理做好充分准备。

Although it is not recommended, an alternative for the Developer is to implement the SingleThreadModel interface which requires the container to guarantee that there is only one request thread at a time in the service method. A servlet container may satisfy this requirement by serializing requests on a servlet, or by maintaining a pool of servlet instances. If the servlet is part of a Web application that has been marked as distributable, the container may maintain a pool of servlet instances in each JVM that the application is distributed across.

> 尽管不建议这样做，但开发人员的另一种选择是实现 SingleThreadModel 接口，该接口要求容器保证服务方法中一次只有一个请求线程。 servlet 容器可以通过序列化 servlet 上的请求或维护 servlet 实例池来满足此要求。如果 servlet 是已标记为可分发的 Web 应用程序的一部分，则容器可以在应用程序分布的每个 JVM 中维护一个 servlet 实例池。

For servlets not implementing the SingleThreadModel interface, if the service method (or methods such as doGet or doPost which are dispatched to the service method of the HttpServlet abstract class) has been defined with the synchronized keyword, the servlet container cannot use the instance pool approach, but must serialize requests through it. It is strongly recommended that Developers not synchronize the service method (or methods dispatched to it) in these circumstances because of detrimental effects on performance.

> 对于没有实现SingleThreadModel接口的servlet，如果service方法（或者分派给HttpServlet抽象类的service方法的doGet或doPost等方法）已经使用synchronized关键字定义，servlet容器就不能使用实例池方法，但必须通过它序列化请求。强烈建议开发人员在这些情况下不要同步服务方法（或分派给它的方法），因为这会对性能产生不利影响。

#### 2.3.3.2 Exceptions During Request Handling 

>2.3.3.2 请求处理期间的异常

A servlet may throw either a `ServletException` or an `UnavailableException` during the service of a request. A `ServletException` signals that some error occurred during the processing of the request and that the container should take appropriate measures to clean up the request.

> Servlet 在请求服务期间可能会抛出 `ServletException` 或 `UnavailableException`。 `ServletException` 表示在处理请求期间发生了一些错误，容器应采取适当的措施来清理请求。

An `UnavailableException` signals that the servlet is unable to handle requests either temporarily or permanently.

> `UnavailableException` 表示 servlet 暂时或永久无法处理请求。

If a permanent unavailability is indicated by the `UnavailableException`, the servlet container must remove the servlet from service, call its destroy method, and release the servlet instance. Any requests refused by the container by that cause must be returned with a `SC_NOT_FOUND` (404) response.

> 如果 `UnavailableException` 指示永久不可用，则 servlet 容器必须从服务中删除 servlet，调用其 destroy 方法，并释放 servlet 实例。容器因该原因拒绝的任何请求都必须返回 `SC_NOT_FOUND` (404) 响应。

If temporary unavailability is indicated by the `UnavailableException`, the container may choose to not route any requests through the servlet during the time period of the temporary unavailability. Any requests refused by the container during this period must be returned with a `SC_SERVICE_UNAVAILABLE` (503) response status along with a Retry-After header indicating when the unavailability will terminate.

> 如果 `UnavailableException` 指示临时不可用，则容器可以选择在临时不可用期间不通过 servlet 路由任何请求。在此期间容器拒绝的任何请求都必须返回 `SC_SERVICE_UNAVAILABLE` (503) 响应状态以及指示不可用性何时终止的 Retry-After 标头。

The container may choose to ignore the distinction between a permanent and temporary unavailability and treat all `UnavailableExceptions` as permanent, thereby removing a servlet that throws any UnavailableException from service.

> 容器可以选择忽略永久不可用和临时不可用之间的区别，并将所有 `UnavailableException` 视为永久不可用，从而从服务中删除抛出任何 UnavailableException 的 servlet。

#### 2.3.3.3 Asynchronous processing 

>2.3.3.3 异步处理

Some times a filter and/or servlet is unable to complete the processing of a request without waiting for a resource or event before generating a response. For example, a servlet may need to wait for an available JDBC connection, for a response from a remote web service, for a JMS message, or for an application event, before proceeding to generate a response. Waiting within the servlet is an inefficient operation as it is a blocking operation that consumes a thread and other limited resources. Frequently a slow resource such as a database may have many threads blocked waiting for access and can cause thread starvation and poor quality of service for an entire web container.

> 有时，如果在生成响应之前不等待资源或事件，过滤器和/或 servlet 就无法完成请求的处理。例如，servlet 可能需要等待可用的 JDBC 连接、来自远程 Web 服务的响应、JMS 消息或应用程序事件，然后再继续生成响应。在 Servlet 内等待是一种低效操作，因为它是一种阻塞操作，会消耗线程和其他有限资源。通常，缓慢的资源（例如数据库）可能会阻塞许多线程等待访问，并可能导致整个 Web 容器的线程匮乏和服务质量差。

The asynchronous processing of requests is introduced to allow the thread may return to the container and perform other tasks. When asynchronous processing begins on the request, another thread or callback may either generate the response and call complete or dispatch the request so that it may run in the context of the container using the `AsyncContext.dispatch` method. A typical sequence of events for asynchronous processing is:

> 引入请求的异步处理是为了允许线程可以返回容器并执行其他任务。当异步处理请求开始时，另一个线程或回调可以生成响应并调用完成或分派请求，以便它可以使用 `AsyncContext.dispatch` 方法在容器的上下文中运行。异步处理的典型事件序列是：

1. The request is received and passed via normal filters for authentication etc. to the servlet.

   > 请求被接收并通过用于身份验证等的普通过滤器传递到 servlet。

2. The servlet processes the request parameters and/or content to determine the nature of the request.

   > Servlet 处理请求参数和/或内容以确定请求的性质。

3. The servlet issues requests for resources or data, for example, sends a remote web service request or joins a queue waiting for a JDBC connection.

   > servlet 发出对资源或数据的请求，例如，发送远程 Web 服务请求或加入等待 JDBC 连接的队列。

4. The servlet returns without generating a response.

   > servlet 返回但不生成响应。

5. After some time, the requested resource becomes available, the thread handling that event continues processing either in the same thread or by dispatching to a resource in the container using the AsyncContext.

   > 一段时间后，请求的资源变得可用，处理该事件的线程在同一线程中继续处理，或者使用 AsyncContext 分派到容器中的资源。

Java Enterprise Edition features such as Section 15.2.2, “Web Application Environment” on page 15-184 and Section 15.3.1, “Propagation of Security Identity in EJBTM Calls” on page 15-186 are available only to threads executing the initial request or when the request is dispatched to the container via the AsyncContext.dispatch method. Java Enterprise Edition features may be available to other threads operating directly on the response object via the `AsyncContext.start(Runnable) `method.

> Java Enterprise Edition 功能（例如第 15-184 页第 15.2.2 节“Web 应用程序环境”和第 15-186 页第 15.3.1 节“EJBTM 调用中的安全身份传播”）仅适用于执行初始请求的线程或者当请求通过 `AsyncContext.dispatch` 方法分派到容器时。 Java Enterprise Edition 功能可用于通过 `AsyncContext.start(Runnable) `方法直接在响应对象上操作的其他线程。

The `@WebServlet` and `@WebFilter `annotations described in Chapter 8 have an attribute - asyncSupported that is a boolean with a default value of false. When asyncSupported is set to true the application can start asynchronous processing in a separate thread by calling `startAsync` (see below), passing it a reference to the request and response objects, and then exit from the container on the original thread. This means that the response will traverse (in reverse order) the same filters (or filter chain) that were traversed on the way in. The response isn’t committed till complete (see below) is called on the `AsyncContext`. The application is responsible to handle concurrent access to the request and response objects if the async task is executing before the container-initiated dispatch that called startAsync has returned to the container.

> 第 8 章中描述的 @WebServlet 和 @WebFilter 注释有一个属性 - asyncSupported，它是一个布尔值，默认值为 false。当 asyncSupported 设置为 true 时，应用程序可以通过调用 startAsync（见下文）在单独的线程中启动异步处理，向其传递对请求和响应对象的引用，然后从原始线程上的容器退出。这意味着响应将遍历（以相反的顺序）与传入时遍历的相同过滤器（或过滤器链）。直到在 AsyncContext 上调用complete（见下文）后才会提交响应。如果异步任务在容器启动的调用 startAsync 的调度返回到容器之前执行，则应用程序负责处理对请求和响应对象的并发访问。

Dispatching from a servlet that has `asyncSupported=true `to one where asyncSupported is set to false is allowed. In this case, the response will be committed when the service method of the servlet that does not support async is exited, and it is the container’s responsibility to call complete on the AsyncContext so that any interested AsyncListener instances will be notified. The `AsyncListener.onComplete` notification should also be used by filters as a mechanism to clear up resources that it has been holding on to for the async task to complete.

> 允许从 asyncSupported=true 的 servlet 分派到 asyncSupported 设置为 false 的 servlet。在这种情况下，当不支持异步的 servlet 的服务方法退出时，将提交响应，并且容器有责任在 AsyncContext 上调用complete，以便任何感兴趣的 AsyncListener 实例都将收到通知。过滤器还应该使用 AsyncListener.onComplete 通知作为一种机制来清除为完成异步任务而一直保留的资源。

Dispatching from a synchronous servlet to an asynchronous servlet would be illegal. However the decision of throwing an `IllegalStateException` is deferred to the point when the application calls `startAsync`. This would allow a servlet to either function as a synchronous or an asynchronous servlet.

> 从同步 servlet 分派到异步 servlet 是非法的。但是，抛出 IllegalStateException 的决定会推迟到应用程序调用 startAsync 时。这将允许 servlet 充当同步或异步 servlet。

The async task that the application is waiting for could write directly to the response, on a different thread than the one that was used for the initial request. This thread knows nothing about any filters. If a filter wanted to manipulate the response in the new thread, it would have to wrap the response when it was processing the initial request “on the way in”, and passed the wrapped response to the next filter in the chain, and eventually to the servlet. So if the response was wrapped (possibly multiple times, once per filter), and the application processes the request and writes directly to the response, it is really writing to the response wrapper(s), i.e., any output added to the response will still be processed by the response wrapper(s). When an application reads from a request in a separate thread, and adds output to the response, it really reads from the request wrapper(s), and writes to the response wrapper(s), so any input and/or output manipulation intended by the wrapper(s) will continue to occur.

> 应用程序正在等待的异步任务可以在与用于初始请求的线程不同的线程上直接写入响应。该线程对任何过滤器一无所知。如果过滤器想要在新线程中操作响应，则必须在处理初始请求“途中”时包装响应，并将包装后的响应传递给链中的下一个过滤器，并最终传递给链中的下一个过滤器。 Servlet。因此，如果响应被包装（可能多次，每个过滤器一次），并且应用程序处理请求并直接写入响应，那么它实际上是写入响应包装器，即添加到响应的任何输出都会仍然由响应包装器处理。当应用程序在单独的线程中读取请求并将输出添加到响应时，它实际上是从请求包装器读取并写入响应包装器，因此任何输入和/或输出操作包装将继续发生。

Alternately if the application chooses to do so it can use the `AsyncContext` to dispatch the request from the new thread to a resource in the container. This would enable using content generation technologies like JSP within the scope of the container.

> 或者，如果应用程序选择这样做，它可以使用 AsyncContext 将请求从新线程分派到容器中的资源。这将允许在容器范围内使用 JSP 等内容生成技术。

In addition to the annotation attributes we have the following methods / classes added:

> 除了注释属性之外，我们还添加了以下方法/类：

- ServletRequest 

  - public `AsyncContext startAsync(ServletRequest req, ServletResponse res)`. This method puts the request into asynchronous mode and initializes it’s `AsyncContext` with the given request and response objects and the time out returned by `getAsyncTimeout`. The `ServletRequest` and `ServletResponse` parameters MUST be either the same objects as were passed to the calling servlet’s service, or the filter’s doFilter method, or be subclasses of `ServletRequestWrapper` or `ServletResponseWrapper` classes that wrap them. A call to this method ensures that the response isn’t committed when the application exits out of the service method. It is committed when `AsyncContext.complete` is called on the returned `AsyncContext` or the `AsyncContext` times out and there are no listeners associated to handle the time out. The timer for async time outs will not start until the request and it’s associated response have returned from the container. The `AsyncContext` could be used to write to the response from the async thread. It can also be used to just notify that the response is not closed and committed.

    > 公共 AsyncContext startAsync(ServletRequest req, ServletResponse res)。此方法将请求置于异步模式，并使用给定的请求和响应对象以及 getAsyncTimeout 返回的超时来初始化其 AsyncContext。 ServletRequest 和 ServletResponse 参数必须是传递给调用 Servlet 服务或过滤器的 doFilter 方法的相同对象，或者是包装它们的 ServletRequestWrapper 或 ServletResponseWrapper 类的子类。调用此方法可确保当应用程序退出服务方法时不会提交响应。当对返回的 AsyncContext 调用 AsyncContext.complete 或 AsyncContext 超时并且没有关联的侦听器来处理超时时，该事件将被提交。直到请求及其关联的响应从容器返回后，异步超时计时器才会启动。 AsyncContext 可用于写入来自异步线程的响应。它还可用于仅通知响应尚未关闭和提交。

    It is illegal to call startAsync if the request is within the scope of a servlet or filter that does not support asynchronous operations, or if the response has been committed and closed, or is called again during the same dispatch. The `AsyncContext` returned from a call to startAsync can then be used for further asynchronous processing. Calling the `AsyncContext.hasOriginalRequestResponse() `on the returned `AsyncContext` will return false, unless the passed `ServletRequest` and `ServletResponse` arguments are the original ones or do not carry application provided wrappers. Any filters invoked in the *outboud* direction after this request was put into asynchronous mode MAY use this as an indication that some of the request and / or response wrappers that they added during their *inbound* invocation MAY need to stay in place for the duration of the asynchronous operation, and their associated resources MAY not be released. A `ServletRequestWrapper` applied during the *inbound* invocation of a filter MAY be released by the *outbound* invocation of the filter only if the given `ServletRequest` which is used to initialize the `AsyncContext` and will be returned by a call to `AsyncContext.getRequest()`, does not contain the said `ServletRequestWrapper`. The same holds true for ServletResponseWrapper instances.

    > 如果请求位于不支持异步操作的 servlet 或过滤器范围内，或者响应已提交并关闭，或者在同一调度期间再次调用，则调用 startAsync 是非法的。然后，从调用 startAsync 返回的 AsyncContext 可用于进一步的异步处理。在返回的 AsyncContext 上调用 AsyncContext.hasOriginalRequestResponse() 将返回 false，除非传递的 ServletRequest 和 ServletResponse 参数是原始参数或者不带有应用程序提供的包装器。在此请求进入异步模式后，在出站方向上调用的任何过滤器都可以使用此指示，表明它们在入站调用期间添加的某些请求和/或响应包装器可能需要在异步持续时间内保持在原位操作，及其相关资源可能不会被释放。仅当用于初始化 AsyncContext 并将通过调用 AsyncContext.getRequest() 返回的给定 ServletRequest 不包含ServletRequestWrapper 说。对于 ServletResponseWrapper 实例也是如此。

  - `public AsyncContext startAsync() `is provided as a convenience that uses the original request and response objects for the async processing. Please note users of this method `SHOULD` flush the response if they are wrapped before calling this method if you wish, to ensure that any data written to the wrapped response isn’t lost.

    > 提供 public AsyncContext startAsync() 是为了方便使用原始请求和响应对象进行异步处理。请注意，如果您愿意，此方法的用户应该在调用此方法之前刷新响应（如果它们被包装），以确保写入包装响应的任何数据不会丢失。

  - `public AsyncContext getAsyncContext() `- returns the `AsyncContext` that was created or re initialized by the invocation of `startAsync`. It is illegal to call `getAsyncContext` if the request has not been put in asynchronous mode.

    > public AsyncContext getAsyncContext() - 返回通过调用 startAsync 创建或重新初始化的 AsyncContext。如果请求尚未置于异步模式，则调用 getAsyncContext 是非法的。

  - `public boolean isAsyncSupported() `- Returns true if the request supports async processing, and false otherwise. Async support will be disabled as soon as the request has passed a filter or servlet that does not support async processing (either via the designated annotation or declaratively).

    > public boolean isAsyncSupported() - 如果请求支持异步处理，则返回 true，否则返回 false。一旦请求通过了不支持异步处理的过滤器或 servlet（通过指定的注释或声明方式），异步支持就会被禁用。

  - `public boolean isAsyncStarted() `- Returns true if async processing has started on this request, and false otherwise. If this request has been dispatched using one of the AsyncContext.dispatch methods since it was put in asynchronous mode, or a call to AsynContext.complete is made, this method returns false.

    > public boolean isAsyncStarted() - 如果已对此请求启动异步处理，则返回 true，否则返回 false。如果此请求自进入异步模式以来已使用 AsyncContext.dispatch 方法之一进行分派，或者调用了 AsynContext.complete，则此方法将返回 false。

  - `public DispatcherType getDispatcherType() `- Returns the dispatcher type of a request. The dispatcher type of a request is used by the container to select the filters that need to be applied to the request. Only filters with the matching dispatcher type and url patterns will be applied. Allowing a filter that has been configured for multiple dispatcher types to query a request for it’s dispatcher type allows the filter to process the request differently depending on it’s dispatcher type. The initial dispatcher type of a request is defined as `DispatcherType.REQUEST`. The dispatcher type of a request dispatched via `RequestDispatcher.forward(ServletRequest, ServletResponse) `or `RequestDispatcher.include(ServletRequest, ServletResponse) `is given as `DispatcherType.FORWARD` or `DispatcherType.INCLUDE` respectively, while a dispatcher type of an asynchronous request dispatched via one of the AsyncContext.dispatch methods is given as DispatcherType.ASYNC. Finally the dispatcher type of a request dispatched to an error page by the container’s error handling mechanism is given as DispatcherType.ERROR.

    > public DispatcherType getDispatcherType() - 返回请求的调度程序类型。容器使用请求的调度程序类型来选择需要应用于请求的过滤器。仅应用具有匹配调度程序类型和 url 模式的过滤器。允许已为多种调度程序类型配置的过滤器查询其调度程序类型的请求，允许过滤器根据其调度程序类型以不同的方式处理请求。请求的初始调度程序类型定义为 DispatcherType.REQUEST。通过 RequestDispatcher.forward(ServletRequest, ServletResponse) 或 RequestDispatcher.include(ServletRequest, ServletResponse) 调度的请求的调度程序类型分别指定为 DispatcherType.FORWARD 或 DispatcherType.INCLUDE，而通过其中之一调度的异步请求的调度程序类型AsyncContext.dispatch 方法作为 DispatcherType.ASYNC 给出。最后，由容器的错误处理机制分派到错误页面的请求的分派程序类型为 DispatcherType.ERROR。

- `AsyncContext` - This class represents the execution context for the asynchronous operation that was started on the ServletRequest. An AsyncContext is created and initialized by a call to ServletRequest.startAsync as described above. The following methods are in the AsyncContext:

  > AsyncContext - 此类表示在 ServletRequest 上启动的异步操作的执行上下文。 AsyncContext 是通过调用 ServletRequest.startAsync 来创建和初始化的，如上所述。 AsyncContext 中有以下方法：

  - `public ServletRequest getRequest() `- returns the request that was used to initialize the AsyncContext by calling one of the startAsync methods. Calling getRequest when complete or any of the dispatch methods has been previously called in the asynchronous cycle will result in an IllegalStateException.

    > public ServletRequest getRequest() - 通过调用 startAsync 方法之一返回用于初始化 AsyncContext 的请求。在完成时调用 getRequest 或先前在异步循环中调用过任何调度方法将导致 IllegalStateException。

  - `public ServletResponse getResponse() `- returns the response that was used to initialize the AsyncContext by calling one of the startAsync methods. Calling getResponse when complete or any of the dispatch methods has been previously called in the asynchronous cycle will result in an IllegalStateException.

    > public ServletResponse getResponse() - 通过调用 startAsync 方法之一返回用于初始化 AsyncContext 的响应。完成后调用 getResponse 或先前在异步循环中调用过任何调度方法将导致 IllegalStateException。

  - `public void setTimeout(long timeoutMilliseconds) `- Sets the time out for the asynchronous processing to occur in milliseconds. A call to this method overrides the time out set by the container. If the time out is not specified via the call to setTimeout, 30000 is used as the default. A value of 0 or less indicates that the asynchronous operation will never time out. The time out applies to the AsyncContext once the container-initiated dispatch during which one of the ServletRequest.startAsync methods was called has returned to the container. It is illegal to set the time out if this method is called after the container-initiated dispatch on which the asynchronous cycle was started has returned to the container and will result in an IllegalStateException.

    > public void setTimeout(long timeoutMilliseconds) - 设置异步处理的超时时间（以毫秒为单位）。对此方法的调用会覆盖容器设置的超时。如果未通过调用 setTimeout 指定超时，则使用 30000 作为默认值。 0 或更小的值表示异步操作永远不会超时。一旦容器启动的调度（期间调用了 ServletRequest.startAsync 方法之一）返回到容器，超时就适用于 AsyncContext。如果在启动异步周期的容器启动的调度返回到容器之后调用此方法，则设置超时是非法的，并将导致 IllegalStateException。

  - `public long getTimeout() `- Gets the time out, in milliseconds, associated with theAsyncContext. This method returns the container’s default time out, or the time out value set via the most recent invocation of setTimeout method.

    > public long getTimeout() - 获取与 AsyncContext 关联的超时（以毫秒为单位）。此方法返回容器的默认超时，或通过最近调用 setTimeout 方法设置的超时值。

  - `public void addListener(AsyncListener listener, ServletRequest req, ServletResponse res) `- Registers the given listener for notifications of onTimeout, onError, onComplete or onStartAsync. The first three are associated with the most recent asynchronous cycle started by calling one of the `ServletRequest.startAsync` methods. The onStartAsync is associated to a new asynchronous cycle via one of the `ServletRequest.startAsync` methods. Async listeners will be notified in the order in which they were added to the request. The request and response objects passed in to the method are the exact same ones that are available from the `AsyncEvent.getSuppliedRequest()` and `AsyncEvent.getSuppliedResponse()` when the AsyncListener is notified. These objects should not be read from or written to, because additional wrapping may have occurred since the given AsyncListener was registered, but may be used in order to release any resources associated with them. It is illegal to call this method after the container-initiated dispatch on which the asynchronous cycle was started has returned to the container and before a new asynchronous cycle was started and will result in an IllegalStateException.

    > public void addListener(AsyncListenerlistener, ServletRequest req, ServletResponse res) - 注册给定监听器以获取 onTimeout、onError、onComplete 或 onStartAsync 的通知。前三个与通过调用 ServletRequest.startAsync 方法之一启动的最近异步周期相关联。 onStartAsync 通过 ServletRequest.startAsync 方法之一与新的异步周期关联。异步侦听器将按照添加到请求的顺序收到通知。传入该方法的请求和响应对象与 AsyncListener 收到通知时从 AsyncEvent.getSuppliedRequest() 和 AsyncEvent.getSuppliedResponse() 中获得的请求和响应对象完全相同。不应读取或写入这些对象，因为自从注册给定的 AsyncListener 后可能会发生额外的包装，但可以使用这些对象来释放与它们关联的任何资源。在启动异步循环的容器启动的调度返回到容器之后、新的异步循环启动之前调用此方法是非法的，并且会导致 IllegalStateException。

  - `public <T extends AsyncListener> createListener(Class<T> clazz)` - Instantiates the given AsyncListener class. The returned AsyncListener instance may be further customized before it is registered with the AsyncContext via a call to one of the addListener methods specified below. The given AsyncListener class MUST define a zero argument constructor, which is used to instantiate it. This method supports any annotations applicable to the AsyncListener.

    > public `<T extends AsyncListener> createListener(Class<T> clazz)` - 实例化给定的 AsyncListener 类。返回的 AsyncListener 实例可以在通过调用下面指定的 addListener 方法之一向 AsyncContext 注册之前进一步自定义。给定的 AsyncListener 类必须定义一个零参数构造函数，用于实例化它。此方法支持适用于 AsyncListener 的任何注释。

  - `public void addListener(AsyncListener) `- Registers the given listener for notifications of onTimeout, onError, onComplete or onStartAsync. The first three are associated with the most recent asynchronous cycle started by calling one of the ServletRequest.startAsync methods. The onStartAsync is associated to a new asynchronous cycle via one of the ServletRequest.startAsync methods. If startAsync(req, res) or startAsync() is called on the request, the exact same request and response objects are available from the AsyncEvent when the AsyncListener is notified. The request and response may or may not be wrapped. Async listeners will be notified in the order in which they were added to the request. It is illegal to call this method after the container-initiateddispatch on which the asynchronous cycle was started has returned to the container and before a new asynchronous cycle was started and will result in an IllegalStateException.

    > public void addListener(AsyncListener) - 注册给定监听器以获取 onTimeout、onError、onComplete 或 onStartAsync 的通知。前三个与通过调用 ServletRequest.startAsync 方法之一启动的最近异步周期相关联。 onStartAsync 通过 ServletRequest.startAsync 方法之一与新的异步周期关联。如果对请求调用 startAsync(req, res) 或 startAsync()，则当通知 AsyncListener 时，可以从 AsyncEvent 获得完全相同的请求和响应对象。请求和响应可能会也可能不会被包装。异步侦听器将按照添加到请求的顺序收到通知。在启动异步周期的容器启动的调度返回到容器之后、新的异步周期开始之前调用此方法是非法的，将导致 IllegalStateException。

  - `public void dispatch(String path) `- Dispatches the request and response that were used to initialize the AsyncContext to the resource with the given path. The given path is interpreted as relative to the ServletContext that initialized the AsyncContext. All path related query methods of the request MUST reflect the dispatch target, while the original request URI, context path, path info and query string may be obtained from the request attributes as defined in Section 9.7.2, “Dispatched Request Parameters” on page 9-100. These attributes MUST always reflect the original path elements, even after multiple dispatches.

    > public void dispatch(String path) - 将用于初始化 AsyncContext 的请求和响应分派到具有给定路径的资源。给定路径被解释为相对于初始化 AsyncContext 的 ServletContext。请求的所有路径相关查询方法必须反映分派目标，而原始请求 URI、上下文路径、路径信息和查询字符串可以从请求属性中获取，如第 9.7.2 节“分派请求参数”中定义的那样9-100。这些属性必须始终反映原始路径元素，即使在多次分派之后也是如此。

  - `public void dispatch() `- Provided as a convenience to dispatch the request and response used to initialize the `AsyncContext` as follows. If the AsyncContext was initialized via the `startAsync(ServletRequest, ServletResponse) `and the request passed is an instance of HttpServletRequest, then the dispatch is to the URI returned by `HttpServletRequest.getRequestURI()`. Otherwise the dispatch is to the URI of the request when it was last dispatched by the container. The examples CODE EXAMPLE 2-1, CODE EXAMPLE 2-2 and CODE EXAMPLE 2-3 shown below demonstrate what the target URI of dispatch would be in the different cases.

    > public void dispatch() - 提供方便地分派用于初始化 AsyncContext 的请求和响应，如下所示。如果 AsyncContext 是通过 startAsync(ServletRequest, ServletResponse) 初始化的，并且传递的请求是 HttpServletRequest 的实例，则分派到 HttpServletRequest.getRequestURI() 返回的 URI。否则，将分派到容器上次分派请求时的 URI。下面显示的示例代码示例 2-1、代码示例 2-2 和代码示例 2-3 演示了在不同情况下调度的目标 URI。

    **CODE EXAMPLE 2-1**

    ```java
    // REQUEST to /url/A
    AsyncContext ac = request.startAsync();
    ...
    ac.dispatch(); // ASYNC dispatch to /url/A
    ```

    **CODE EXAMPLE 2-2**

    ```java
    // REQUEST to /url/A
    // FORWARD to /url/B
    request.getRequestDispatcher(“/url/B”).forward(request,
    response);
    // Start async operation from within the target of the FORWARD
    AsyncContext ac = request.startAsync();
    ac.dispatch(); // ASYNC dispatch to /url/A
    ```

    **CODE EXAMPLE 2-3**

    ```java
    // REQUEST to /url/A
    // FORWARD to /url/B
    request.getRequestDispatcher(“/url/B”).forward(request,
    response);
    
    // Start async operation from within the target of the FORWARD
    AsyncContext ac = request.startAsync(request, response);
    ac.dispatch(); // ASYNC dispatch to /url/B
    ```

  - `public void dispatch(ServletContext context, String path) `- dispatches the request and response used to initialize the `AsyncContext` to the resource with the given path in the given ServletContext.

    > public void dispatch(ServletContext context, String path) - 将用于初始化 AsyncContext 的请求和响应分派到给定 ServletContext 中具有给定路径的资源。

  - For all the 3 variations of the dispatch methods defined above, calls to the methods returns immediately after passing the request and response objects to a container managed thread, on which the dispatch operation will be performed. The dispatcher type of the request is set to `ASYNC`. Unlike `RequestDispatcher.forward(ServletRequest, ServletResponse) `dispatches, the response buffer and headers will not be reset, and it is legal to dispatch even if the response has already been committed. Control over the request and response is delegated to the dispatch target, and the response will be closed when the dispatch target has completed execution, unless `ServletRequest.startAsync() `or `ServletRequest.startAsync(ServletRequest, ServletResponse) `is called. If any of the dispatch methods are called before the container-initiated dispatch that called startAsync has returned to the container, then the call will not take effect until after the container-initiated dispatch has returned to the container. Invocation of the `AsyncListener.onComplete(AsyncEvent)`, `AsyncListener.onTimeout(AsyncEvent) `and `AsyncListener.onError(AsyncEvent) `will also be delayed till after the container-initiated dispatch has returned to the container. There can be at most one asynchronous dispatch operation per asynchronous cycle, which is started by a call to one of the `ServletRequest.startAsync` methods. There can be at most one asynchronous dispatch per asynchronous cycle, which is started by a call to `ServletRequest.startAsync`. Any attempt to perform additional asynchronous dispatch operation within the same asynchronous cycle is illegal and will result in an `IllegalStateException`. If `startAsync` is subsequently called on the dispatched request, then any of the dispatch methods may be called with the same restriction as above.

    > 对于上面定义的所有 3 种分派方法的变体，在将请求和响应对象传递到容器管理的线程（将在该线程上执行分派操作）后，对方法的调用立即返回。请求的调度程序类型设置为 ASYNC。与 RequestDispatcher.forward(ServletRequest, ServletResponse) 调度不同，响应缓冲区和标头不会重置，即使响应已经提交，调度也是合法的。对请求和响应的控制委托给调度目标，并且当调度目标完成执行时，响应将被关闭，除非调用 ServletRequest.startAsync() 或 ServletRequest.startAsync(ServletRequest, ServletResponse)。如果在调用 startAsync 的容器启动的调度返回到容器之前调用任何调度方法，则该调用只有在容器启动的调度返回到容器之后才会生效。 AsyncListener.onComplete(AsyncEvent)、AsyncListener.onTimeout(AsyncEvent) 和 AsyncListener.onError(AsyncEvent) 的调用也将延迟到容器启动的调度返回到容器之后。每个异步周期最多可以有一个异步分派操作，该操作通过调用 ServletRequest.startAsync 方法之一启动。每个异步周期最多可以有一个异步调度，该异步调度是通过调用 ServletRequest.startAsync 启动的。任何在同一异步周期内执行额外异步调度操作的尝试都是非法的，并且将导致 IllegalStateException。 如果随后对分派请求调用 startAsync，则可以使用与上述相同的限制来调用任何分派方法。

  - Any errors or exceptions that may occur during the execution of the dispatch methods `MUST` be caught and handled by the container as follows:

    > 执行调度方法期间可能发生的任何错误或异常必须由容器捕获并处理，如下所示：

    - i. invoke the `AsyncListener.onError(AsyncEvent) `method for all instances of the AsyncListener registered with the ServletRequest for which the AsyncContext was created and make the Throwable available via the 	.

      > 为注册到 ServletRequest（为其创建 AsyncContext）的所有 AsyncListener 实例调用 AsyncListener.onError(AsyncEvent) 方法，并通过 AsyncEvent.getThrowable() 使 Throwable 可用。

    - ii. If none of the listeners called `AsyncContext.complete` or any of the `AsyncContext.dispatch` methods, then perform an error dispatch with a status code equal to `HttpServletResponse.SC_INTERNAL_SERVER_ERROR` and make the Throwable available as the value of the `RequestDispatcher.ERROR_EXCEPTION` request attribute.

      > 如果没有侦听器调用 AsyncContext.complete 或任何 AsyncContext.dispatch 方法，则执行状态代码等于 HttpServletResponse.SC_INTERNAL_SERVER_ERROR 的错误分派，并使 Throwable 可用作 RequestDispatcher.ERROR_EXCEPTION 请求属性的值。

    - iii. If no matching error page is found, or the error page does not call `AsyncContext.complete() `or any of the `AsyncContext.dispatch` methods, then the container `MUST` call `AsyncContext.complete`.

      > 如果没有找到匹配的错误页面，或者错误页面没有调用 AsyncContext.complete() 或任何 AsyncContext.dispatch 方法，则容器必须调用 AsyncContext.complete。

  - `public boolean hasOriginalRequestAndResponse() `- This method checks if the `AsyncContext` was initialized with the original request and response objects by calling `ServletRequest.startAsync() `or if it was initialized by calling `ServletRequest.startAsync(ServletRequest, ServletResponse) `and neither the `ServletRequest` nor the `ServletResponse` argument carried any application provided wrappers, in which case it returns true. If the `AsyncContext` was initialized with wrapped request and/or response objects using `ServletRequest.startAsync(ServletRequest, ServletResponse)`, it returns false. This information may be used by filters invoked in the *outbound* direction, after a request was put into asynchronous mode, to determine whether any request and/or response wrappers that they added during their *inbound* invocation need to be preserved for the duration of the asynchronous operation or may be released.

    > public boolean hasOriginalRequestAndResponse() - 此方法检查 AsyncContext 是否是通过调用 ServletRequest.startAsync() 使用原始请求和响应对象初始化的，还是通过调用 ServletRequest.startAsync(ServletRequest, ServletResponse) 初始化的，而不是 ServletRequest 和 ServletResponse参数携带任何应用程序提供的包装器，在这种情况下它返回 true。如果使用 ServletRequest.startAsync(ServletRequest, ServletResponse) 使用包装的请求和/或响应对象初始化 AsyncContext，则它返回 false。在将请求置于异步模式之后，在出站方向上调用的过滤器可以使用此信息来确定它们在入站调用期间添加的任何请求和/或响应包装器是否需要在异步操作期间保留或可能被释放。

  - `public void start(Runnable r) `- This method causes the container to dispatch a thread, possibly from a managed thread pool, to run the specified Runnable. The container may propagate appropriate contextual information to the Runnable.

    > public void start(Runnable r) - 此方法使容器分派一个线程（可能来自托管线程池）来运行指定的 Runnable。容器可以将适当的上下文信息传播到Runnable。

  - `public void complete() `- If request.startAsync is called then this method `MUST` be called to complete the async processing and commit and close the response. The complete method can be invoked by the container if the request is dispatched to a servlet that does not support async processing, or the target servlet called by AsyncContext.dispatch does not do a subsequent call to `startAsync`. In this case, it is the container’s responsibility to call complete() as soon as that servlet’s service method is exited. An `IllegalStateException` MUST be thrown if startAsync was not called. It is legal to call this method anytime after a call to `ServletRequest.startAsync() `or `ServletRequest.startAsync(ServletRequest, ServletResponse) `and before a call to one of the dispatch methods. If this method is called before the container-initiated dispatch that called startAsync has returned to the container, then the call will not take effect until after the container-initiated dispatch has returned to the container. Invocation of the `AsyncListener.onComplete(AsyncEvent) `will also be delayed till after the container-initiated dispatch has returned to the container.

    > public void Complete() - 如果调用 request.startAsync，则必须调用此方法来完成异步处理并提交和关闭响应。如果请求分派到不支持异步处理的 Servlet，或者 AsyncContext.dispatch 调用的目标 Servlet 不执行对 startAsync 的后续调用，则容器可以调用 Complete 方法。在这种情况下，一旦 Servlet 的服务方法退出，容器就有责任调用complete()。如果未调用 startAsync，则必须抛出 IllegalStateException。在调用 ServletRequest.startAsync() 或 ServletRequest.startAsync(ServletRequest, ServletResponse) 之后以及调用其中一种调度方法之前，随时调用此方法都是合法的。如果在调用 startAsync 的容器启动的调度返回到容器之前调用此方法，则只有在容器启动的调度返回到容器之后，该调用才会生效。 AsyncListener.onComplete(AsyncEvent) 的调用也将被延迟，直到容器启动的调度返回到容器之后。

- `ServletRequestWrapper`

  - `public boolean isWrapperFor(ServletRequest req)` - Checks recursively if this wrapper wraps the given ServletRequest and returns true if it does, else it returns false

    > public boolean isWrapperFor(ServletRequest req) - 递归地检查此包装器是否包装了给定的 ServletRequest，如果是则返回 true，否则返回 false

- `ServletResponseWrapper`

  - `public boolean isWrapperFor(ServletResponse res)` - Checks recursively if this wrapper wraps the given ServletResponse and returns true if it does, else it returns false.

    > public boolean isWrapperFor(ServletResponse res) - 递归检查此包装器是否包装给定的 ServletResponse，如果是则返回 true，否则返回 false。

- `AsyncListener` 

  - `public void onComplete(AsyncEvent event) `- Is used to notify the listener of completion of the asynchronous operation started on the `ServletRequest`.

    > public void onComplete(AsyncEvent event) - 用于通知侦听器 ServletRequest 上启动的异步操作已完成。

  - `public void onTimeout(AsyncEvent event) `- Is used to notify the listener of a time out of the asynchronous operation started on the `ServletRequest`.

    > public void onTimeout(AsyncEvent event) - 用于通知侦听器 ServletRequest 上启动的异步操作超时。

  - `public void onError(AsyncEvent event)` - Is used to notify the listener that the asynchronous operation has failed to complete.

    > public void onError(AsyncEvent event) - 用于通知侦听器异步操作未能完成。

  - `public void onStartAsync(AsyncEvent event) `- Is used to notify the listener that a new asynchronous cycle is being initiated via a call to one of the `ServletRequest.startAsync` methods. The AsyncContext corresponding to the asynchronous operation that is being reinitialized may be obtained by calling `AsyncEvent.getAsyncContext` on the given event.

    > public void onStartAsync(AsyncEvent event) - 用于通知侦听器正在通过调用 ServletRequest.startAsync 方法之一来启动新的异步周期。与正在重新初始化的异步操作相对应的 AsyncContext 可以通过对给定事件调用 AsyncEvent.getAsyncContext 来获取。

■ In through the following steps:

> 通过以下步骤：

the event that an asynchronous operation times out, the container must run

> 如果异步操作超时，容器必须运行

- Invoke the AsyncListener.onTimeout method on all the AsyncListener instances registered with the `ServletRequest` on which the asynchronous operation was initiated.

  > 在向启动异步操作的 ServletRequest 注册的所有 AsyncListener 实例上调用 AsyncListener.onTimeout 方法。

- If none of the listeners called `AsyncContext.complete() `or any of the AsyncContext.dispatch methods, perform an error dispatch with a status code equal to `HttpServletResponse.SC_INTERNAL_SERVER_ERROR`.

  > 如果没有侦听器调用 AsyncContext.complete() 或任何 AsyncContext.dispatch 方法，则执行状态代码等于 HttpServletResponse.SC_INTERNAL_SERVER_ERROR 的错误调度。

- If no matching error page was found, or the error page did not call `AsyncContext.complete() `or any of the `AsyncContext.dispatch` methods, the container `MUST` call `AsyncContext.complete()`.

  > 如果没有找到匹配的错误页面，或者错误页面没有调用 AsyncContext.complete() 或任何 AsyncContext.dispatch 方法，则容器必须调用 AsyncContext.complete()。

- If an exception is thrown while invoking methods in an `AsyncListener`, it is logged and will not affect the invocation of any other `AsyncListeners`.

  > 如果在调用 AsyncListener 中的方法时引发异常，则会记录该异常，并且不会影响任何其他 AsyncListener 的调用。

- Async processing in JSP would not be supported by default as it is used for content generation and async processing would have to be done before the content generation. It is up to the container how to handle this case. Once all the async activities are done, a dispatch to the JSP page using the `AsyncContext.dispatch` can be used for generating content.

  > 默认情况下不支持 JSP 中的异步处理，因为它用于内容生成，并且异步处理必须在内容生成之前完成。如何处理这种情况取决于容器。所有异步活动完成后，可以使用 AsyncContext.dispatch 调度到 JSP 页面来生成内容。

Figure 2-1 shown below is a diagram depicting the state transitions for various asynchronous operations.

> 下面的图 2-1 描述了各种异步操作的状态转换。



#### 2.3.3.4 Thread Safety 

>2.3.3.4 线程安全

Other than the `startAsync` and `complete` methods, implementations of the request and response objects are not guaranteed to be thread safe. This means that they should either only be used within the scope of the request handling thread or the application must ensure that access to the request and response objects are thread safe.

> 除了 startAsync 和 Complete 方法之外，请求和响应对象的实现不保证线程安全。这意味着它们应该仅在请求处理线程的范围内使用，或者应用程序必须确保对请求和响应对象的访问是线程安全的。

If a thread created by the application uses the container-managed objects, such as the request or response object, those objects must be accessed only within the object’s life cycle as defined in sections Section 3.12, “Lifetime of the Request Object” on page 3-31and Section 5.7, “Lifetime of the Response Object” on page 5-50 respectively. Be aware that other than the startAsync, and complete methods, the request and response objects are not thread safe. If those objects were accessed in the multiple threads, the access should be synchronized or be done through a wrapper to add the thread safety, for instance, synchronizing the call of the methods to access the request attribute, or using a local output stream for the response object within a thread.

> 如果应用程序创建的线程使用容器管理的对象，例如请求或响应对象，则必须仅在对象的生命周期内访问这些对象，如第 3 页第 3.12 节“请求对象的生命周期”中所定义。 -31 和第 5-50 页第 5.7 节“响应对象的生命周期”。请注意，除了 startAsync 和 Complete 方法之外，请求和响应对象都不是线程安全的。如果在多个线程中访问这些对象，则应该同步访问或通过包装器来完成访问以添加线程安全性，例如，同步调用访问请求属性的方法，或者使用本地输出流来访问请求属性。线程内的响应对象。

#### 2.3.3.5 Upgrade Processing 

>2.3.3.5 升级处理

In HTTP/1.1, the Upgrade general-header allows the client to specify the additional communication protocols that it supports and would like to use. If the server finds it appropriate to switch protocols, then new protocols will be used in subsequent communication.

> 在 HTTP/1.1 中，升级通用标头允许客户端指定它支持并希望使用的附加通信协议。如果服务器认为切换协议合适，则后续通信将使用新协议。

The servlet container provides an HTTP upgrade mechanism. However the servlet container itself does not have knowledge about the upgraded protocol. The protocol processing is encapsulated in the HttpUpgradeHandler. Data reading or writing between the servlet container and the HttpUpgradeHandler is in byte streams.

> servlet容器提供了HTTP升级机制。然而，Servlet 容器本身并不了解升级后的协议。协议处理封装在HttpUpgradeHandler中。 servlet 容器和 HttpUpgradeHandler 之间的数据读取或写入是在字节流中。

When an upgrade request is received, the servlet can invoke the `HttpServletRequest.upgrade` method, which starts the upgrade process. This method instantiates the given HttpUpgradeHandler class. The returned `HttpUpgradeHandler` instance may be further customized. The application prepares and sends an appropriate response to the client. After exiting the service method of the servlet, the servlet container completes the processing of all filters and marks the connection to be handled by the HttpUpgradeHandler. It then calls the HttpUpgradeHandler’s init method, passing a WebConnection to allow the protocol handler access to the data streams.

> 当收到升级请求时，Servlet 可以调用 HttpServletRequest.upgrade 方法，该方法将启动升级过程。此方法实例化给定的 HttpUpgradeHandler 类。返回的 HttpUpgradeHandler 实例可以进一步定制。应用程序准备并向客户端发送适当的响应。退出servlet的service方法后，servlet容器完成所有过滤器的处理，并将连接标记为由HttpUpgradeHandler处理。然后，它调用 HttpUpgradeHandler 的 init 方法，传递 WebConnection 以允许协议处理程序访问数据流。

The servlet filters only process the initial HTTP request and response. They are not involved in subsequent communications. In other words, they are not invoked once the request has been upgraded.

> Servlet 过滤器仅处理初始 HTTP 请求和响应。他们不参与后续的通讯。换句话说，一旦请求升级，它们就不会被调用。

The HttpUpgradeHandler may use non blocking IO to consume and produce messages.

> HttpUpgradeHandler 可以使用非阻塞 IO 来消费和生成消息。

The Developer has the responsibility for thread safe access to the ServletInputStream and ServletOutputStream while processing HTTP upgrade.

> 开发人员负责在处理 HTTP 升级时对 ServletInputStream 和 ServletOutputStream 进行线程安全访问。

When the upgrade processing is done, HttpUpgradeHandler.destroy will be invoked.

> 升级处理完成后，将调用 HttpUpgradeHandler.destroy。

### 2.3.4 End of Service 

>2.3.4 服务结束

The servlet container is not required to keep a servlet loaded for any particular period of time. A servlet instance may be kept active in a servlet container for a period of milliseconds, for the lifetime of the servlet container (which could be a number of days, months, or years), or any amount of time in between.

> servlet 容器不需要在任何特定时间段内保持 servlet 的加载状态。 servlet 实例可以在 servlet 容器中保持活动状态一段时间（毫秒）、servlet 容器的生命周期（可以是几天、几个月或几年），或者其间的任何时间量。

When the servlet container determines that a servlet should be removed from service, it calls the destroy method of the Servlet interface to allow the servlet to release any resources it is using and save any persistent state. For example, the container may do this when it wants to conserve memory resources, or when it is being shut down.

> 当 servlet 容器确定应从服务中删除 servlet 时，它会调用 Servlet 接口的 destroy 方法，以允许 servlet 释放它正在使用的任何资源并保存任何持久状态。例如，当容器想要节省内存资源或正在关闭时，容器可能会执行此操作。

Before the servlet container calls the destroy method, it must allow any threads that are currently running in the service method of the servlet to complete execution, or exceed a server-defined time limit.

> 在servlet容器调用destroy方法之前，它必须允许当前正在servlet的service方法中运行的任何线程完成执行，或者超过服务器定义的时间限制。

Once the destroy method is called on a servlet instance, the container may not route other requests to that instance of the servlet. If the container needs to enable the servlet again, it must do so with a new instance of the servlet’s class.

> 一旦对 servlet 实例调用 destroy 方法，容器就不能将其他请求路由到该 servlet 实例。如果容器需要再次启用 servlet，则必须使用 servlet 类的新实例来执行此操作。

After the destroy method completes, the servlet container must release the servlet instance so that it is eligible for garbage collection.

> destroy 方法完成后，servlet 容器必须释放 servlet 实例，以便它有资格进行垃圾回收。